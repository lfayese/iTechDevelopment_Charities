<#
.SYNOPSIS
    Creates an OSDCloud ISO with a custom WIM file and PowerShell 7 support.
.DESCRIPTION
    Creates a complete OSDCloud ISO with a custom WIM file and PowerShell 7 support.
.PARAMETER WimPath
    Path to the Windows Image (WIM) file to include in the ISO.
.PARAMETER OutputPath
    Directory path where the ISO file will be created.
.PARAMETER ISOFileName
    Name of the ISO file (default: "OSDCloudCustomWIM.iso").
.PARAMETER TempPath
    Temporary storage path (default: "$env:TEMP\OSDCloudCustomBuilder").
.PARAMETER PowerShellVersion
    PowerShell version to include (default: "7.3.4").
.PARAMETER IncludeWinRE
    Includes Windows Recovery Environment in the ISO.
.PARAMETER SkipCleanup
    Skips cleanup of temporary files.
.PARAMETER TimeoutMinutes
    Maximum execution time in minutes (default: 60).
.EXAMPLE
    Add-CustomWimWithPwsh7 -WimPath "C:\Path\to\windows.wim" -OutputPath "C:\OSDCloud"
#>
function Add-CustomWimWithPwsh7 {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [ValidateScript({(Test-Path $_ -PathType Leaf) -and ($_ -match '\.wim$')})]
        [string]$WimPath,
        
        [Parameter(Mandatory = $true)]
        [string]$OutputPath,
        
        [string]$ISOFileName = "OSDCloudCustomWIM.iso",
        [string]$TempPath = "$env:TEMP\OSDCloudCustomBuilder",
        [ValidatePattern('^\d+\.\d+\.\d+$')]
        [string]$PowerShellVersion = "7.3.4",
        [switch]$IncludeWinRE,
        [switch]$SkipCleanup,
        [int]$TimeoutMinutes = 60
    )
    
    begin {
        $errorCollection = @()
        $operationTimeout = (Get-Date).AddMinutes($TimeoutMinutes)
        $jobs = @()
        $currentOperation = "Initialization"
        
        # Validate environment
        if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
            throw "Administrator privileges required. Please run as administrator."
        }
        
        # Check disk space
        try {
            $drive = (Split-Path $TempPath -Qualifier) + '\'
            $freeSpace = (Get-PSDrive -Name $drive[0] -ErrorAction Stop).Free
            if ($freeSpace -lt 15GB) {
                throw "Insufficient disk space. Need 15GB, only $(($freeSpace/1GB).ToString('N2'))GB available on $drive"
            }
        } 
        catch { $errorCollection += "Disk space check failed: $_" }
        
        # Setup paths
        $workspacePath = Join-Path $TempPath "Workspace"
        $tempWorkspacePath = Join-Path $TempPath "TempWorkspace"
        $OutputPath = if (-not $OutputPath.EndsWith(".iso")) { Join-Path $OutputPath $ISOFileName } else { $OutputPath }
        $outputDirectory = Split-Path $OutputPath -Parent
        
        # Create required directories
        @($workspacePath, $tempWorkspacePath, $outputDirectory) | 
            Where-Object { -not (Test-Path $_) } | 
            ForEach-Object { New-Item -Path $_ -ItemType Directory -Force | Out-Null }
    }
    
    process {
        try {
            # Copy WIM file
            $currentOperation = "Copying WIM file"
            Write-Host "Copying custom WIM to workspace..." -ForegroundColor Cyan
            Copy-CustomWimToWorkspace -WimPath $WimPath -WorkspacePath $workspacePath -UseRobocopy
            
            # Start parallel jobs
            $currentOperation = "Starting parallel processes"
            
            # PowerShell 7 customization job
            Write-Host "Adding PowerShell $PowerShellVersion support to WinPE..." -ForegroundColor Cyan
            $jobs += Start-Job -ScriptBlock {
                param($tempPath, $workspacePath, $psVersion)
                try {
                    Customize-WinPEWithPowerShell7 -TempPath $tempPath -WorkspacePath $workspacePath -PowerShellVersion $psVersion
                    return @{ Success = $true; Message = "PowerShell 7 customization completed" }
                } catch {
                    return @{ Success = $false; Message = "PowerShell 7 customization failed: $_" }
                }
            } -ArgumentList $tempWorkspacePath, $workspacePath, $PowerShellVersion
            
            # ISO optimization job
            Write-Host "Optimizing ISO size..." -ForegroundColor Cyan
            $jobs += Start-Job -ScriptBlock {
                param($workspacePath)
                try {
                    Optimize-ISOSize -WorkspacePath $workspacePath
                    return @{ Success = $true; Message = "ISO optimization completed" }
                } catch {
                    return @{ Success = $false; Message = "ISO optimization failed: $_" }
                }
            } -ArgumentList $workspacePath
            
            # Wait for job completion
            $currentOperation = "Processing background jobs"
            if (-not (Wait-Job -Job $jobs -Timeout 1200)) { # 20 minutes timeout
                throw "Background jobs timed out after 20 minutes"
            }
            
            # Process job results
            $failedJobs = $jobs | ForEach-Object {
                $result = Receive-Job -Job $_
                if (-not $result.Success) { $errorCollection += $result.Message }
                $result
            } | Where-Object { -not $_.Success }
            
            if ($failedJobs) {
                throw "Background tasks failed: $($failedJobs.Message -join ', ')"
            }
            
            # Create ISO file
            $currentOperation = "Creating ISO file"
            Write-Host "Creating custom ISO: $OutputPath" -ForegroundColor Cyan
            New-CustomISO -WorkspacePath $workspacePath -OutputPath $OutputPath -IncludeWinRE:$IncludeWinRE
            
            if (-not (Test-Path $OutputPath)) {
                throw "ISO file was not created at $OutputPath"
            }
            
            # Generate summary
            $currentOperation = "Generating summary"
            Show-Summary -WindowsImage $WimPath -ISOPath $OutputPath -IncludeWinRE:$IncludeWinRE
            
            Write-Host "âœ… ISO created successfully at: $OutputPath" -ForegroundColor Green
        }
        catch {
            Write-Error "Error during '$currentOperation': $_"
            if ($errorCollection.Count -gt 0) {
                Write-Host "Error details:" -ForegroundColor Red
                $errorCollection | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }
            }
            throw
        }
        finally {
            # Clean up jobs
            $jobs | Where-Object { $_ } | ForEach-Object {
                if ($_.State -ne 'Completed') { Stop-Job -Job $_ -ErrorAction SilentlyContinue }
                Remove-Job -Job $_ -Force -ErrorAction SilentlyContinue
            }
            
            # Clean up temporary files
            if (-not $SkipCleanup) {
                Write-Host "Cleaning up temporary files..." -ForegroundColor Cyan
                @($tempWorkspacePath, $workspacePath) | 
                Where-Object { Test-Path $_ } |
                ForEach-Object { 
                    Remove-Item -Path $_ -Recurse -Force -ErrorAction SilentlyContinue
                    if (Test-Path $_) { Write-Warning "Could not completely remove: $_" }
                }
            }
            else {
                Write-Host "Skipping cleanup as requested. Temp files at: $TempPath" -ForegroundColor Yellow
            }
        }
    }
    
    end {
        if ($errorCollection.Count -gt 0) {
            Write-Warning "Completed with $($errorCollection.Count) warning(s)/error(s)"
        }
    }
}